<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发编程 - Phaser | Emil`s Blog</title><meta name="keywords" content="java,concurrent"><meta name="author" content="Emil"><meta name="copyright" content="Emil"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Phaser: Phaser 是 JDK 1.7 新增的一个同步辅助类，在功能上跟 CyclicBarrier 和 CountDownLatch 差不多，但支持更丰富的用法。与 JUC 中多数同步类不同，它并不是通过 AQS 来实现的，而是用了另外一种同步机制。 我们可以将 Phaser 看成一个一个的阶段，每个阶段都有需要执行的线程任务，任务执行完毕就进入下一个阶段。所以 Phaser 特别适合"><meta property="og:type" content="article"><meta property="og:title" content="并发编程 - Phaser"><meta property="og:url" content="https://blog.hvnobug.com/post/concurrent-phaser.html"><meta property="og:site_name" content="Emil&#96;s Blog"><meta property="og:description" content="Phaser: Phaser 是 JDK 1.7 新增的一个同步辅助类，在功能上跟 CyclicBarrier 和 CountDownLatch 差不多，但支持更丰富的用法。与 JUC 中多数同步类不同，它并不是通过 AQS 来实现的，而是用了另外一种同步机制。 我们可以将 Phaser 看成一个一个的阶段，每个阶段都有需要执行的线程任务，任务执行完毕就进入下一个阶段。所以 Phaser 特别适合"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/58.png"><meta property="article:published_time" content="2021-04-07T14:13:12.000Z"><meta property="article:modified_time" content="2021-04-29T03:35:56.976Z"><meta property="article:author" content="Emil"><meta property="article:tag" content="java"><meta property="article:tag" content="concurrent"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/58.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/hvnobug/assets/common/favicon.ico"><link rel="canonical" href="https://blog.hvnobug.com/post/concurrent-phaser"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin="crossorigin"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/pwa/manifest.json"><meta name="msapplication-TileColor" content="#fff"><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?39cbf1602bb584a9c817fbe7b061c842";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-153501439-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-153501439-1")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-04-29 11:35:56"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap span{color:#fff;text-decoration:underline;cursor:pointer}.snackbar-pos.bottom-left{bottom:70px}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Emil`s Blog" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/common/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-sitemap"></i><span> 统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/album/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/nav/"><i class="fa-fw fa fa-map"></i><span> 网址导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/58.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Emil`s Blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-sitemap"></i><span> 统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/album/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/nav/"><i class="fa-fw fa fa-map"></i><span> 网址导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">并发编程 - Phaser</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-07T14:13:12.000Z" title="发表于 2021-04-07 22:13:12">2021-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-29T03:35:56.976Z" title="更新于 2021-04-29 11:35:56">2021-04-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/concurrent/">concurrent</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note info flat"><p><strong>Phaser</strong>:</p><p><code>Phaser</code> 是 <code>JDK 1.7</code> 新增的一个同步辅助类，在功能上跟 <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 差不多，但支持更丰富的用法。与 <code>JUC</code> 中多数同步类不同，它并不是通过 <code>AQS</code> 来实现的，而是用了另外一种同步机制。<br>我们可以将 <code>Phaser</code> 看成一个一个的阶段，每个阶段都有需要执行的线程任务，任务执行完毕就进入下一个阶段。所以 <code>Phaser</code> 特别适合使用在重复执行或者重用的情况。</p><table><thead><tr><th>同步器</th><th>作用</th></tr></thead><tbody><tr><td><code>CountDownLatch</code></td><td>倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器值归<strong>0</strong>后，所有等待的线程继续执行</td></tr><tr><td><code>CyclicBarrier</code></td><td>循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行</td></tr><tr><td><code>Phaser</code></td><td>多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（<code>advance</code>）</td></tr></tbody></table></div><h2 id="phase"><a class="markdownIt-Anchor" href="#phase"></a> phase</h2><p>在 <code>CyclicBarrier</code> 中，只有一个栅栏，线程在到达栅栏后会等待其它线程的到达。</p><blockquote><p><code>Phaser</code> 也有栅栏，在 <code>Phaser</code> 中，栅栏的名称叫做 <code>phase</code>(阶段)，在任意时间点，<code>Phaser</code> 只处于某一个 <code>phase</code>(阶段)，初始阶段为<strong>0</strong>，最大达到 <code>Integer.MAX_VALUE</code>，然后再次归零。当所有 <code>parties</code> 参与者都到达后，<code>phase</code> 值会递增。</p></blockquote><h2 id="parties"><a class="markdownIt-Anchor" href="#parties"></a> parties</h2><p><code>parties</code>(参与者)其实就是 <code>CyclicBarrier</code> 中的参与线程的概念。</p><blockquote><p><code>CyclicBarrier</code> 中的参与者在初始构造指定后就不能变更，而 <code>Phaser</code> 既可以在初始构造时指定参与者的数量，也可以中途通过<code>register</code>、<code>bulkRegister</code>、<code>arriveAndDeregister</code>等方法注册/注销参与者。</p></blockquote><h2 id="arriveadvance"><a class="markdownIt-Anchor" href="#arriveadvance"></a> arrive/advance</h2><blockquote><p><code>Phaser</code> 注册完 <code>parties</code>（参与者）之后，参与者的初始状态是 <code>unarrived</code> 的，当参与者到达（<code>arrive</code>）当前阶段（<code>phase</code>）后，状态就会变成 <code>arrived</code>。当阶段的到达参与者数满足条件后（注册的数量等于到达的数量），阶段就会发生进阶（<code>advance</code>）——也就是 <code>phase</code> 值 <strong>+1</strong>。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/loading/11.gif" data-lazy-src="https://segmentfault.com/img/bVbfk33?w=335&amp;h=526" alt="arrive/advance"></p><h2 id="termination"><a class="markdownIt-Anchor" href="#termination"></a> termination</h2><p>代表当前 <code>Phaser</code> 对象达到终止状态，有点类似于 <code>CyclicBarrier</code> 中的栅栏被破坏的概念。</p><h2 id="tiering"><a class="markdownIt-Anchor" href="#tiering"></a> tiering</h2><blockquote><p><code>Phaser</code> 支持分层（<code>Tiering</code>） —— 一种树形结构，通过构造函数可以指定当前待构造的 <code>Phaser</code> 对象的父结点。之所以引入 <code>Tiering</code>，是因为当一个 <code>Phaser</code> 有大量参与者（<code>parties</code>）的时候，内部的同步操作会使性能急剧下降，而分层可以降低竞争，从而减小因同步导致的额外开销。<br>在一个分层 <code>Phasers</code> 的树结构中，注册和撤销子 <code>Phaser</code> 或父 <code>Phaser</code> 是自动被管理的。当一个 <code>Phaser</code> 的参与者（<code>parties</code>）数量变成0时，如果有该 <code>Phaser</code> 有父结点，就会将它从父结点中溢移除。</p></blockquote><h2 id="核心属性"><a class="markdownIt-Anchor" href="#核心属性"></a> 核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Primary state representation, holding four bit-fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * unarrived  -- the number of parties yet to hit barrier (bits  0-15)</span></span><br><span class="line"><span class="comment"> * parties    -- the number of parties to wait            (bits 16-31)</span></span><br><span class="line"><span class="comment"> * phase      -- the generation of the barrier            (bits 32-62)</span></span><br><span class="line"><span class="comment"> * terminated -- set if barrier is terminated             (bit  63 / sign)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except that a phaser with no registered parties is</span></span><br><span class="line"><span class="comment"> * distinguished by the otherwise illegal state of having zero</span></span><br><span class="line"><span class="comment"> * parties and one unarrived parties (encoded as EMPTY below).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To efficiently maintain atomicity, these values are packed into</span></span><br><span class="line"><span class="comment"> * a single (atomic) long. Good performance relies on keeping</span></span><br><span class="line"><span class="comment"> * state decoding and encoding simple, and keeping race windows</span></span><br><span class="line"><span class="comment"> * short.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All state updates are performed via CAS except initial</span></span><br><span class="line"><span class="comment"> * registration of a sub-phaser (i.e., one with a non-null</span></span><br><span class="line"><span class="comment"> * parent).  In this (relatively rare) case, we use built-in</span></span><br><span class="line"><span class="comment"> * synchronization to lock while first registering with its</span></span><br><span class="line"><span class="comment"> * parent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The phase of a subphaser is allowed to lag that of its</span></span><br><span class="line"><span class="comment"> * ancestors until it is actually accessed -- see method</span></span><br><span class="line"><span class="comment"> * reconcileState.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The parent of this phaser, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root of phaser tree. Equals this if not in a tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heads of Treiber stacks for waiting threads. To eliminate</span></span><br><span class="line"><span class="comment"> * contention when releasing some threads while adding others, we</span></span><br><span class="line"><span class="comment"> * use two of them, alternating across even and odd phases.</span></span><br><span class="line"><span class="comment"> * Subphasers share queues with root to speed up releases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; evenQ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; oddQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br></pre></td></tr></table></figure><ol><li><strong>state</strong> <code>Phaser</code> 使用一个 <code>long</code> 型 <code>state</code> 值来标识内部状态：<ul><li><strong>unarrived</strong>(低<strong>0-15</strong>位) 表示未到达 <code>barrier</code> 的 <code>parties</code> 数</li><li><strong>parties</strong>(中<strong>16-31</strong>位) 表示等待的 <code>parties</code> 数</li><li><strong>phase</strong>(中<strong>32-62</strong>位) 表示 <code>phase</code> 当前的 <code>Generation</code></li><li><strong>terminated</strong>(高<strong>63</strong>位) 表示当前 <code>phaser</code> 的终止状态。</li></ul></li><li><strong>parent</strong> 表示当前 <code>phaser</code> 的父 <code>phaser</code>, 可能为空</li><li><strong>root</strong> 表示当前 <code>phaser</code> 数的根 <code>phaser</code></li><li><strong>evenQ/oddQ</strong> 等待线程的栈顶元素,根据 <code>phase</code> 取模定义为一个奇数 <code>header</code> 和一个偶数 <code>header</code></li><li><strong>UNSAFE</strong> <code>Unsafe</code> 类实例,用于操作内存</li><li><strong>stateOffset</strong> <code>state</code> 变量的内存偏移量</li></ol><h2 id="qnode"><a class="markdownIt-Anchor" href="#qnode"></a> QNode</h2><blockquote><p><code>QNode</code> 是 <code>Phaser</code> 定义的内部等待队列，用于在阻塞时记录等待线程及相关信息。实现了<code>ForkJoinPool</code> 的一个内部接口 <code>ManagedBlocker</code>。<br><code>Phaser</code> 也可能被 <code>ForkJoinPool</code> 中的任务使用，这样在其他任务阻塞等待一个 <code>phase</code> 时可以保证足够的并行度来执行任务(通过内部实现方法 <code>isReleasable</code> 和 <code>block</code>)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wait nodes for Treiber stack representing wait queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> <span class="keyword">implements</span> <span class="title">ForkJoinPool</span>.<span class="title">ManagedBlocker</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前 phaser</span></span><br><span class="line">    <span class="keyword">final</span> Phaser phaser;</span><br><span class="line">    <span class="comment">// 当前的 phase 值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="comment">// 是否可中断</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> interruptible;</span><br><span class="line">    <span class="comment">// 是否支持超时</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> timed;</span><br><span class="line">    <span class="comment">// 是否已中断</span></span><br><span class="line">    <span class="keyword">boolean</span> wasInterrupted;</span><br><span class="line">    <span class="comment">// 超时时长,单位纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanos;</span><br><span class="line">    <span class="comment">// 若支持超时,nanos 等于创建 QNode 的系统时间 + nanos,否则 nanos = 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line">    <span class="comment">// 当前节点线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// nulled to cancel wait</span></span><br><span class="line">    <span class="comment">// QNode 是一个的单向链表,next 是该节点的后继节点</span></span><br><span class="line">    QNode next;</span><br><span class="line"></span><br><span class="line">    QNode(Phaser phaser, <span class="keyword">int</span> phase, <span class="keyword">boolean</span> interruptible,<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        <span class="keyword">this</span>.phase = phase;</span><br><span class="line">        <span class="keyword">this</span>.interruptible = interruptible;</span><br><span class="line">        <span class="keyword">this</span>.nanos = nanos;</span><br><span class="line">        <span class="keyword">this</span>.timed = timed;</span><br><span class="line">        <span class="keyword">this</span>.deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        thread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReleasable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (phaser.getPhase() != phase) &#123;</span><br><span class="line">            thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInterrupted &amp;&amp; interruptible) &#123;</span><br><span class="line">            thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">block</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isReleasable())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        <span class="keyword">return</span> isReleasable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new phaser with no initially registered parties, no</span></span><br><span class="line"><span class="comment"> * parent, and initial phase number 0. Any thread using this</span></span><br><span class="line"><span class="comment"> * phaser will need to first register for it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new phaser with the given number of registered</span></span><br><span class="line"><span class="comment"> * unarrived parties, no parent, and initial phase number 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of parties required to advance to the</span></span><br><span class="line"><span class="comment"> * next phase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if parties less than zero</span></span><br><span class="line"><span class="comment"> * or greater than the maximum number of parties supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>(<span class="keyword">null</span>, parties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Equivalent to &#123;<span class="doctag">@link</span> #Phaser(Phaser, int) Phaser(parent, 0)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent the parent phaser</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>(parent, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a new phaser with the given parent and number of</span></span><br><span class="line"><span class="comment">* registered unarrived parties.  When the given parent is non-null</span></span><br><span class="line"><span class="comment">* and the given number of parties is greater than zero, this</span></span><br><span class="line"><span class="comment">* child phaser is registered with its parent.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent the parent phaser</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parties the number of parties required to advance to the</span></span><br><span class="line"><span class="comment">* next phase</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if parties less than zero</span></span><br><span class="line"><span class="comment">* or greater than the maximum number of parties supported</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent, <span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &gt;&gt;&gt; PARTIES_SHIFT != <span class="number">0</span>) <span class="comment">// 无符号右移 16 位,不为 0 说明 parties 超出了最大限制</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal number of parties&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> phase = <span class="number">0</span>; <span class="comment">// 初始 phase 为 0</span></span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 parent 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser root = parent.root; <span class="comment">// 获取 phaser 的根节点</span></span><br><span class="line">        <span class="keyword">this</span>.root = root; <span class="comment">// 将 root 指向根节点</span></span><br><span class="line">        <span class="keyword">this</span>.evenQ = root.evenQ; <span class="comment">// 共用根节点的偶数&quot;无锁栈&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.oddQ = root.oddQ; <span class="comment">// 共用根节点的奇数&quot;无锁栈&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (parties != <span class="number">0</span>) <span class="comment">// 如果注册的 parties 不为零</span></span><br><span class="line">            phase = parent.doRegister(<span class="number">1</span>); <span class="comment">// 向父节点注册 1 个 party 表示自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在父节点,说明当前节点作为根节点注册</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.evenQ = <span class="keyword">new</span> AtomicReference&lt;QNode&gt;();</span><br><span class="line">        <span class="keyword">this</span>.oddQ = <span class="keyword">new</span> AtomicReference&lt;QNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并更新 state</span></span><br><span class="line">    <span class="keyword">this</span>.state = (parties == <span class="number">0</span>) ? (<span class="keyword">long</span>)EMPTY :</span><br><span class="line">        ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) |</span><br><span class="line">        ((<span class="keyword">long</span>)parties &lt;&lt; PARTIES_SHIFT) |</span><br><span class="line">        ((<span class="keyword">long</span>)parties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心方法"><a class="markdownIt-Anchor" href="#核心方法"></a> 核心方法</h2><h3 id="register"><a class="markdownIt-Anchor" href="#register"></a> register</h3><blockquote><p>在 <code>CyclicBarrier</code>、<code>CountDownLatch</code> 中，我们使用计数器来控制程序的顺序执行，同样的在 <code>Phaser</code> 中也是通过计数器来控制。<br>在 <code>Phaser</code> 中计数器叫做 <code>parties</code>， 我们可以通过 <code>Phaser</code> 的构造函数或者 <code>register()</code> 方法来注册。<br>通过调用 <code>register()</code> 方法，我们可以动态的控制 <code>phaser</code> 的个数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new unarrived party to this phaser.  If an ongoing</span></span><br><span class="line"><span class="comment"> * invocation of &#123;<span class="doctag">@link</span> #onAdvance&#125; is in progress, this method</span></span><br><span class="line"><span class="comment"> * may await its completion before returning.  If this phaser has</span></span><br><span class="line"><span class="comment"> * a parent, and this phaser previously had no registered parties,</span></span><br><span class="line"><span class="comment"> * this child phaser is also registered with its parent. If</span></span><br><span class="line"><span class="comment"> * this phaser is terminated, the attempt to register has</span></span><br><span class="line"><span class="comment"> * no effect, and a negative value is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the arrival phase number to which this registration</span></span><br><span class="line"><span class="comment"> * applied.  If this value is negative, then this phaser has</span></span><br><span class="line"><span class="comment"> * terminated, in which case registration has no effect.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if attempting to register more</span></span><br><span class="line"><span class="comment"> * than the maximum supported number of parties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRegister(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the given number of new unarrived parties to this phaser.</span></span><br><span class="line"><span class="comment"> * If an ongoing invocation of &#123;<span class="doctag">@link</span> #onAdvance&#125; is in progress,</span></span><br><span class="line"><span class="comment"> * this method may await its completion before returning.  If this</span></span><br><span class="line"><span class="comment"> * phaser has a parent, and the given number of parties is greater</span></span><br><span class="line"><span class="comment"> * than zero, and this phaser previously had no registered</span></span><br><span class="line"><span class="comment"> * parties, this child phaser is also registered with its parent.</span></span><br><span class="line"><span class="comment"> * If this phaser is terminated, the attempt to register has no</span></span><br><span class="line"><span class="comment"> * effect, and a negative value is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of additional parties required to</span></span><br><span class="line"><span class="comment"> * advance to the next phase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the arrival phase number to which this registration</span></span><br><span class="line"><span class="comment"> * applied.  If this value is negative, then this phaser has</span></span><br><span class="line"><span class="comment"> * terminated, in which case registration has no effect.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if attempting to register more</span></span><br><span class="line"><span class="comment"> * than the maximum supported number of parties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties &lt; 0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulkRegister</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (parties == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> getPhase();</span><br><span class="line">    <span class="keyword">return</span> doRegister(parties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>register</code> 和 <code>bulkRegister</code> 都是可以动态注册指定数量的 <code>Phaser</code>,其核心都由 <code>doRegister</code> 实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of register, bulkRegister</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registrations number to add to both parties and</span></span><br><span class="line"><span class="comment"> * unarrived fields. Must be greater than zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doRegister</span><span class="params">(<span class="keyword">int</span> registrations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// adjustment to state</span></span><br><span class="line">    <span class="comment">// 首先计算注册后当前State要调整的值adjust</span></span><br><span class="line">    <span class="keyword">long</span> adjust = ((<span class="keyword">long</span>)registrations &lt;&lt; PARTIES_SHIFT) | registrations;</span><br><span class="line">    <span class="keyword">final</span> Phaser parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (parent == <span class="keyword">null</span>) ? state : reconcileState(); <span class="comment">// reconcileState()调整当前 Phaser 的 State 与root一致</span></span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> parties = counts &gt;&gt;&gt; PARTIES_SHIFT;                 <span class="comment">// 参与者数目</span></span><br><span class="line">        <span class="keyword">int</span> unarrived = counts &amp; UNARRIVED_MASK;                <span class="comment">// 未到达的数目</span></span><br><span class="line">        <span class="keyword">if</span> (registrations &gt; MAX_PARTIES - parties)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badRegister(s));</span><br><span class="line">        phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);                       <span class="comment">// 当前Phaser所处的阶段phase </span></span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (counts != EMPTY) &#123;                                  <span class="comment">// CASE1: 当前Phaser已经注册过参与者</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span> || reconcileState() == s) &#123;</span><br><span class="line">                 <span class="comment">// 参与者已全部到达栅栏, 当前 Phaser 正在 Advance, 需要阻塞等待这一过程完成</span></span><br><span class="line">                <span class="keyword">if</span> (unarrived == <span class="number">0</span>)             <span class="comment">// wait out advance</span></span><br><span class="line">                    root.internalAwaitAdvance(phase, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 否则,直接更新 State</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset,</span><br><span class="line">                                                    s, s + adjust))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CASE2: 当前 Phaser 未注册过参与者（第一次注册）,且没有父结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;              <span class="comment">// 1st root registration</span></span><br><span class="line">            <span class="keyword">long</span> next = ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust;</span><br><span class="line">            <span class="comment">// CAS更新当前 Phaser 的 state 值</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, next))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CASE3: 当前 Phaser 未注册过参与者（第一次注册）,且有父结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;               <span class="comment">// 1st sub registration</span></span><br><span class="line">                <span class="keyword">if</span> (state == s) &#123;               <span class="comment">// recheck under lock</span></span><br><span class="line">                    phase = parent.doRegister(<span class="number">1</span>); <span class="comment">// 向父结点注册一个参与者</span></span><br><span class="line">                    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// finish registration whenever parent registration</span></span><br><span class="line">                    <span class="comment">// succeeded, even when racing with termination,</span></span><br><span class="line">                    <span class="comment">// since these are part of the same &quot;transaction&quot;.</span></span><br><span class="line">                    <span class="keyword">while</span> (!UNSAFE.compareAndSwapLong</span><br><span class="line">                            (<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                            ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust)) &#123;</span><br><span class="line">                        s = state;</span><br><span class="line">                        phase = (<span class="keyword">int</span>)(root.state &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">                        <span class="comment">// assert (int)s == EMPTY;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> phase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果当前操作不是首次注册，那么直接在当前 <code>phaser</code> 上更新注册 <code>parties</code> 数 (如果当前未到达数为<strong>0</strong>，说明上一代 <code>phase</code> 正在进行到达操作，此时调用 <code>internalAwaitAdvance()</code> 方法等待其他任务完成到达操作)</li><li>如果是首次注册，并且当前 <code>phaser</code> 没有父节点，说明是 <code>root</code> 节点注册，直接更新 <code>phase</code></li><li>如果当前操作是首次注册，并且当前 <code>phaser</code> 由父节点，则注册操作交由父节点，并更新当前 <code>phaser</code> 的 <code>phase</code>。由于子 <code>Phaser</code> 的 <code>phase</code> 在没有被真正使用之前，允许滞后于它的 <code>root</code> 节点。非首次注册时，如果 <code>Phaser</code> 有父节点，则调用 <code>reconcileState()</code>方法解决 <code>root</code> 节点的 <code>phase</code> 延迟传递问题。</li></ol><h3 id="reconcilestate"><a class="markdownIt-Anchor" href="#reconcilestate"></a> reconcileState</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolves lagged phase propagation from root if necessary.</span></span><br><span class="line"><span class="comment"> * Reconciliation normally occurs when root has advanced but</span></span><br><span class="line"><span class="comment"> * subphasers have not yet done so, in which case they must finish</span></span><br><span class="line"><span class="comment"> * their own advance by setting unarrived to parties (or if</span></span><br><span class="line"><span class="comment"> * parties is zero, resetting to unregistered EMPTY state).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> reconciled state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">reconcileState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> phase, p;</span><br><span class="line">        <span class="comment">// CAS to root phase with current parties, tripping unarrived</span></span><br><span class="line">        <span class="keyword">while</span> ((phase = (<span class="keyword">int</span>)(root.state &gt;&gt;&gt; PHASE_SHIFT)) !=</span><br><span class="line">                (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT) &amp;&amp;</span><br><span class="line">                !UNSAFE.compareAndSwapLong</span><br><span class="line">                (<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                s = (((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) |</span><br><span class="line">                        ((phase &lt; <span class="number">0</span>) ? (s &amp; COUNTS_MASK) :</span><br><span class="line">                        (((p = (<span class="keyword">int</span>)s &gt;&gt;&gt; PARTIES_SHIFT) == <span class="number">0</span>) ? EMPTY :</span><br><span class="line">                        ((s &amp; PARTIES_MASK) | p))))))</span><br><span class="line">            s = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>root</code> 节点的 <code>phase</code> 已经 <code>advance</code> 到下一代，但是子节点 <code>phaser</code> 还没有，这种情况下它们必须通过更新未到达 <code>parties</code> 数 完成它们自己的 <code>advance</code> 操作(如果 <code>parties</code> 为<strong>0</strong>，重置为 <code>EMPTY</code> 状态)。</p><h3 id="internalawaitadvance"><a class="markdownIt-Anchor" href="#internalawaitadvance"></a> internalAwaitAdvance</h3><blockquote><p><code>internalAwaitAdvance</code> 的主要逻辑就是：当前参与者线程等待 <code>Phaser</code> 进入下一个阶段(就是 <code>phase</code> 值变化).</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Possibly blocks and waits for phase to advance unless aborted.</span></span><br><span class="line"><span class="comment"> * Call only on root phaser.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phase current phase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node if non-null, the wait node to track interrupt and timeout;</span></span><br><span class="line"><span class="comment"> * if null, denotes noninterruptible wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> current phase 返回新的阶段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">internalAwaitAdvance</span><span class="params">(<span class="keyword">int</span> phase, QNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert root == this;</span></span><br><span class="line">    <span class="comment">// 清空不用的Treiber Stack（奇偶Stack交替使用）</span></span><br><span class="line">    releaseWaiters(phase-<span class="number">1</span>);          <span class="comment">// ensure old queue clean</span></span><br><span class="line">    <span class="comment">// 入队标识</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;           <span class="comment">// true when node is enqueued</span></span><br><span class="line">    <span class="keyword">int</span> lastUnarrived = <span class="number">0</span>;            <span class="comment">// to increase spins upon change</span></span><br><span class="line">    <span class="keyword">int</span> spins = SPINS_PER_ARRIVAL;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">while</span> ((p = (<span class="keyword">int</span>)((s = state) &gt;&gt;&gt; PHASE_SHIFT)) == phase) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;           <span class="comment">// spinning in noninterruptible mode</span></span><br><span class="line">            <span class="keyword">int</span> unarrived = (<span class="keyword">int</span>)s &amp; UNARRIVED_MASK;</span><br><span class="line">            <span class="keyword">if</span> (unarrived != lastUnarrived &amp;&amp;</span><br><span class="line">                (lastUnarrived = unarrived) &lt; NCPU)</span><br><span class="line">                spins += SPINS_PER_ARRIVAL;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.interrupted();</span><br><span class="line">            <span class="keyword">if</span> (interrupted || --spins &lt; <span class="number">0</span>) &#123; <span class="comment">// need node to record intr</span></span><br><span class="line">                node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">                node.wasInterrupted = interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已完成或中止</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.isReleasable()) <span class="comment">// done or aborted</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将结点压入栈顶</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued) &#123;           <span class="comment">// push onto queue</span></span><br><span class="line">            AtomicReference&lt;QNode&gt; head = (phase &amp; <span class="number">1</span>) == <span class="number">0</span> ? evenQ : oddQ;</span><br><span class="line">            QNode q = node.next = head.get();</span><br><span class="line">            <span class="keyword">if</span> ((q == <span class="keyword">null</span> || q.phase == phase) &amp;&amp;</span><br><span class="line">                (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT) == phase) <span class="comment">// avoid stale enq</span></span><br><span class="line">                queued = head.compareAndSet(q, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞等待</span></span><br><span class="line">                ForkJoinPool.managedBlock(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                node.wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.thread != <span class="keyword">null</span>)</span><br><span class="line">            node.thread = <span class="keyword">null</span>;       <span class="comment">// avoid need for unpark()</span></span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted &amp;&amp; !node.interruptible)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">if</span> (p == phase &amp;&amp; (p = (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT)) == phase)</span><br><span class="line">            <span class="keyword">return</span> abortWait(phase); <span class="comment">// possibly clean up on abort</span></span><br><span class="line">    &#125;</span><br><span class="line">    releaseWaiters(phase);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数 <code>node</code>，如果不为空，则说明等待线程需要追踪<strong>中断状态</strong>或<strong>超时状态</strong>。以 <code>doRegister</code> 中的调用为例，不考虑线程争用，<code>internalAwaitAdvance</code> 大概流程如下：</p><ol><li>首先调用 <code>releaseWaiters</code> 唤醒上一代所有等待线程，确保旧队列中没有遗留的等待线程。</li><li>循环 <code>SPINS_PER_ARRIVAL</code> 指定的次数或者当前线程被中断，创建 <code>node</code> 记录等待线程及相关信息。</li><li>继续循环调用 <code>ForkJoinPool.managedBlock</code> 运行被阻塞的任务</li><li>继续循环，阻塞任务运行成功被释放，跳出循环</li><li>最后唤醒当前 <code>phase</code> 的线程</li></ol><h3 id="arrive"><a class="markdownIt-Anchor" href="#arrive"></a> arrive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Arrives at this phaser, without waiting for others to arrive.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is a usage error for an unregistered party to invoke this</span></span><br><span class="line"><span class="comment"> * method.  However, this error may result in an &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * IllegalStateException&#125; only upon some subsequent operation on</span></span><br><span class="line"><span class="comment"> * this phaser, if ever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the arrival phase number, or a negative value if terminated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if not terminated and the number</span></span><br><span class="line"><span class="comment"> * of unarrived parties would become negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doArrive(ONE_ARRIVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main implementation for methods arrive and arriveAndDeregister.</span></span><br><span class="line"><span class="comment"> * Manually tuned to speed up and minimize race windows for the</span></span><br><span class="line"><span class="comment"> * common case of just decrementing unarrived field.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> adjust value to subtract from state;</span></span><br><span class="line"><span class="comment"> *               ONE_ARRIVAL for arrive,</span></span><br><span class="line"><span class="comment"> *               ONE_DEREGISTER for arriveAndDeregister</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doArrive</span><span class="params">(<span class="keyword">int</span> adjust)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> unarrived = (counts == EMPTY) ? <span class="number">0</span> : (counts &amp; UNARRIVED_MASK);</span><br><span class="line">        <span class="keyword">if</span> (unarrived &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badArrive(s));</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, s-=adjust)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unarrived == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> n = s &amp; PARTIES_MASK;  <span class="comment">// base of next state</span></span><br><span class="line">                <span class="keyword">int</span> nextUnarrived = (<span class="keyword">int</span>)n &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onAdvance(phase, nextUnarrived))</span><br><span class="line">                        n |= TERMINATION_BIT;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>)</span><br><span class="line">                        n |= EMPTY;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        n |= nextUnarrived;</span><br><span class="line">                    <span class="keyword">int</span> nextPhase = (phase + <span class="number">1</span>) &amp; MAX_PHASE;</span><br><span class="line">                    n |= (<span class="keyword">long</span>)nextPhase &lt;&lt; PHASE_SHIFT;</span><br><span class="line">                    UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, n);</span><br><span class="line">                    releaseWaiters(phase);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>) &#123; <span class="comment">// propagate deregistration</span></span><br><span class="line">                    phase = parent.doArrive(ONE_DEREGISTER);</span><br><span class="line">                    UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset,</span><br><span class="line">                                                s, s | EMPTY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    phase = parent.doArrive(ONE_ARRIVAL);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>arrive</code> 方法手动调整到达数，使当前线程到达 <code>phaser</code>。<code>arrive</code> 和 <code>arriveAndDeregister</code> 都调用了 <code>doArrive</code> 实现，大概流程如下：</p><ol><li>首先更新 <code>state</code>(state - adjust)</li><li>如果当前不是最后一个未到达的任务，直接返回 <code>phase</code></li><li>如果当前是最后一个未到达的任务<ul><li>如果当前是 <code>root</code> 节点，判断是否需要终止 <code>phaser</code>，<code>CAS</code> 更新 <code>phase</code>，最后释放等待的线程；</li><li>如果是分层结构，并且已经没有下一代未到达的parties，则交由父节点处理 <code>doArrive</code> 逻辑，然后更新 <code>state</code> 为 <code>EMPTY</code>。</li></ul></li></ol><h3 id="arriveandawaitadvance"><a class="markdownIt-Anchor" href="#arriveandawaitadvance"></a> arriveAndAwaitAdvance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Arrives at this phaser and awaits others. Equivalent in effect</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@code</span> awaitAdvance(arrive())&#125;.  If you need to await with</span></span><br><span class="line"><span class="comment"> * interruption or timeout, you can arrange this with an analogous</span></span><br><span class="line"><span class="comment"> * construction using one of the other forms of the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * awaitAdvance&#125; method.  If instead you need to deregister upon</span></span><br><span class="line"><span class="comment"> * arrival, use &#123;<span class="doctag">@code</span> awaitAdvance(arriveAndDeregister())&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is a usage error for an unregistered party to invoke this</span></span><br><span class="line"><span class="comment"> * method.  However, this error may result in an &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * IllegalStateException&#125; only upon some subsequent operation on</span></span><br><span class="line"><span class="comment"> * this phaser, if ever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the arrival phase number, or the (negative)</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getPhase() current phase&#125; if terminated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if not terminated and the number</span></span><br><span class="line"><span class="comment"> * of unarrived parties would become negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Specialization of doArrive+awaitAdvance eliminating some reads/paths</span></span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> unarrived = (counts == EMPTY) ? <span class="number">0</span> : (counts &amp; UNARRIVED_MASK); <span class="comment">// 获取未到达数</span></span><br><span class="line">        <span class="keyword">if</span> (unarrived &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badArrive(s));</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                                        s -= ONE_ARRIVAL)) &#123; <span class="comment">// 更新state</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>); <span class="comment">// 阻塞等待其他任务</span></span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> parent.arriveAndAwaitAdvance(); <span class="comment">// 子Phaser交给父节点处理</span></span><br><span class="line">            <span class="keyword">long</span> n = s &amp; PARTIES_MASK;  <span class="comment">// base of next state</span></span><br><span class="line">            <span class="keyword">int</span> nextUnarrived = (<span class="keyword">int</span>)n &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (onAdvance(phase, nextUnarrived)) <span class="comment">// 全部到达，检查是否可销毁</span></span><br><span class="line">                n |= TERMINATION_BIT;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>)</span><br><span class="line">                n |= EMPTY;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n |= nextUnarrived;</span><br><span class="line">            <span class="keyword">int</span> nextPhase = (phase + <span class="number">1</span>) &amp; MAX_PHASE; <span class="comment">// 计算下一代phase</span></span><br><span class="line">            n |= (<span class="keyword">long</span>)nextPhase &lt;&lt; PHASE_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (!UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, n)) <span class="comment">// 更新state</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT); <span class="comment">// terminated</span></span><br><span class="line">            releaseWaiters(phase); <span class="comment">// 释放等待phase的线程</span></span><br><span class="line">            <span class="keyword">return</span> nextPhase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使当前线程到达 <code>phaser</code> 并等待其他任务到达，等价于 <code>awaitAdvance(arrive())</code>。如果需要等待中断或超时，可以使用 <code>awaitAdvance</code> 方法完成一个类似的构造。如果需要在到达后取消注册，可以使用 <code>awaitAdvance(arriveAndDeregister())</code>。效果类似于<code>CyclicBarrier.await</code>。大概流程如下：</p></blockquote><ol><li>更新 <code>state(state - 1)</code>；</li><li>如果未到达数大于<strong>1</strong>，调用 <code>internalAwaitAdvance</code> 阻塞等待其他任务到达，返回当前 <code>phase</code></li><li>如果为分层结构，则交由父节点处理 <code>arriveAndAwaitAdvance</code> 逻辑</li><li>如果未到达数 <strong>&lt;=1</strong>，判断 <code>phaser</code> 终止状态，<code>CAS</code> 更新 <code>phase</code> 到下一代，最后释放等待当前 <code>phase</code> 的线程，并返回下一代 <code>phase</code>。</li></ol><h3 id="awaitadvance"><a class="markdownIt-Anchor" href="#awaitadvance"></a> awaitAdvance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Awaits the phase of this phaser to advance from the given phase</span></span><br><span class="line"><span class="comment"> * value, returning immediately if the current phase is not equal</span></span><br><span class="line"><span class="comment"> * to the given phase value or this phaser is terminated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phase an arrival phase number, or negative value if</span></span><br><span class="line"><span class="comment"> * terminated; this argument is normally the value returned by a</span></span><br><span class="line"><span class="comment"> * previous call to &#123;<span class="doctag">@code</span> arrive&#125; or &#123;<span class="doctag">@code</span> arriveAndDeregister&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the next arrival phase number, or the argument if it is</span></span><br><span class="line"><span class="comment"> * negative, or the (negative) &#123;<span class="doctag">@linkplain</span> #getPhase() current phase&#125;</span></span><br><span class="line"><span class="comment"> * if terminated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase)</span><br><span class="line">        <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>awaitAdvance</code> 用于阻塞等待线程到达，直到 <code>phase</code> 前进到下一代，返回下一代的 <code>phase number</code>。方法很简单，不多赘述。<code>awaitAdvanceInterruptibly</code> 方法是响应中断版的 <code>awaitAdvance</code>，不同之处在于，调用阻塞时会记录线程的中断状态。</p><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><blockquote><p>通过 <code>Phaser</code> 控制多个线程的执行时机：有时候我们希望所有线程到达指定点后再同时开始执行，我们可以利用<code>CyclicBarrier</code> 或 <code>CountDownLatch</code> 来实现，这里给出使用 <code>Phaser</code> 的版本。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">        phaser.register();                  <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> phase = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            <span class="comment">// TODO do something</span></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;【%s】: 执行完任务，当前 phase = %s&quot;</span>, Thread.currentThread().getName(), phase));</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-&quot;</span> + index).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例中，创建了<strong>10</strong>个线程，并通过 <code>register</code> 方法注册 <code>Phaser</code> 的参与者数量为 <strong>10</strong>。当某个线程调用<code>arriveAndAwaitAdvance</code> 方法后，<code>arrive</code> 数量会加<strong>1</strong>，如果数量没有满足总数（参与者数量<strong>10</strong>），当前线程就是一直等待，当最后一个线程到达后，所有线程都会继续往下执行。</p><div class="note warning flat"><p><strong>注意</strong>：<br><code>arriveAndAwaitAdvance</code> 方法是不响应中断的，也就是说即使当前线程被中断，<code>arriveAndAwaitAdvance</code> 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 <code>awaitAdvanceInterruptibly</code> 方法。</p></div><blockquote><p>通过 <code>Phaser</code> 实现开关。我们希望一些外部条件得到满足后，然后打开开关，线程才能继续执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);       <span class="comment">// 注册主线程,当外部条件满足时,由主线程打开开关</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        phaser.register();                      <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> phase = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            <span class="comment">// TODO do something</span></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;【%s】: 执行完任务，当前 phase = %s&quot;</span>, Thread.currentThread().getName(), phase));</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部条件:等待用户输入命令</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Press ENTER to continue&quot;</span>);</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    reader.readLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开开关</span></span><br><span class="line">    phaser.arriveAndDeregister();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程打开了开关&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Phaser</code> 支持分层功能，我们先来考虑下如何用利用 <code>Phaser</code> 的分层来实现高并发时的优化</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/loading/11.gif" data-lazy-src="https://segmentfault.com/img/bVbfk75?w=3206&amp;h=1136" alt="phaser"></p><blockquote><p>如果任务数继续增大，那么同步产生的开销会非常大，利用 <code>Phaser</code> 分层的功能，我们可以限定每个 <code>Phaser</code> 对象的最大使用线程（任务数）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/loading/11.gif" data-lazy-src="https://segmentfault.com/img/bVbfk9h?w=4371&amp;h=1751" alt="phaser"></p><p>可以看到，上述 <code>Phasers</code> 其实构成了一颗多叉树，如果任务数继续增多，还可以将 <code>Phaser</code> 的叶子结点继续分裂，然后将分裂出的子结点供工作线程使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> repeats = <span class="number">3</span>;    <span class="comment">// 指定任务最多执行的次数</span></span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(</span><br><span class="line">                    <span class="string">&quot;---------------PHASE[%s],Parties[%s] ---------------&quot;</span>,</span><br><span class="line">                    phase, registeredParties));</span><br><span class="line">            <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= repeats || registeredParties == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Runnable[] tasks = <span class="keyword">new</span> Runnable[<span class="number">10</span>];</span><br><span class="line">    build(tasks, <span class="number">0</span>, tasks.length, phaser);       <span class="comment">// 根据任务数,为每个任务分配 Phaser 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; tasks.length; index++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Tasker(index, phaser)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Runnable[] taskers, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Phaser phaser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tasksPerPhaser = <span class="number">4</span>;      <span class="comment">// 每个Phaser对象对应的工作线程（任务）数</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &gt; tasksPerPhaser) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i += tasksPerPhaser) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = Math.min(i + tasksPerPhaser, hi);</span><br><span class="line">            build(taskers, i, j, <span class="keyword">new</span> Phaser(phaser));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; ++i)</span><br><span class="line">            taskers[i] = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tasker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    Tasker(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        <span class="keyword">this</span>.phaser.register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tasker(<span class="keyword">int</span> count, Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>(phaser);</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!phaser.isTerminated()) &#123;   <span class="comment">//只要 Phaser 没有终止, 各个线程的任务就会一直执行</span></span><br><span class="line">            <span class="keyword">int</span> phase = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            <span class="comment">// TODO do something</span></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;【%s】: 执行完任务，当前 count = %s&quot;</span>, Thread.currentThread().getName(), count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e5794645ca8d">JUC源码分析-Phaser</a></li><li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015979879">Java多线程进阶—Phaser</a></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Emil</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.hvnobug.com/post/concurrent-phaser.html">https://blog.hvnobug.com/post/concurrent-phaser.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.hvnobug.com" target="_blank">Emil`s Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/concurrent/">concurrent</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/58.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/medias/reward/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/medias/reward/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/medias/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/medias/reward/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/concurrent-semaphore.html"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/57.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发编程 - Semaphore</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/concurrent-semaphore.html" title="并发编程 - Semaphore"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/57.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-03</div><div class="title">并发编程 - Semaphore</div></div></a></div><div><a href="/post/concurrent-cyclicbarrier.html" title="并发编程 - CyclicBarrier"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/56.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">并发编程 - CyclicBarrier</div></div></a></div><div><a href="/post/concurrent-countdownlatch.html" title="并发编程 - CountDownLatch"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/54.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">并发编程 - CountDownLatch</div></div></a></div><div><a href="/post/concurrent-reentrantreadwritelock.html" title="并发编程 - ReentrantReadWriteLock"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/54.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-12</div><div class="title">并发编程 - ReentrantReadWriteLock</div></div></a></div><div><a href="/post/concurrent-reentrantlock.html" title="并发编程 - ReentrantLock"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/53.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-03</div><div class="title">并发编程 - ReentrantLock</div></div></a></div><div><a href="/post/concurrent-aqs.html" title="并发编程 - AQS"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/52.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-21</div><div class="title">并发编程 - AQS</div></div></a></div><div><a href="/post/jdk-source-stringbuilder.html" title="死磕Jdk源码之StringBuilder"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/33.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-20</div><div class="title">死磕Jdk源码之StringBuilder</div></div></a></div><div><a href="/post/jdk-source-hashset.html" title="死磕Jdk源码之HashSet"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/32.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-19</div><div class="title">死磕Jdk源码之HashSet</div></div></a></div><div><a href="/post/jdk-source-hashmap.html" title="死磕Jdk源码之HashMap"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/31.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-18</div><div class="title">死磕Jdk源码之HashMap</div></div></a></div><div><a href="/post/jdk-source-linkedlist.html" title="死磕Jdk源码之LinkedList"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/30.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-17</div><div class="title">死磕Jdk源码之LinkedList</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/common/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">Emil</div><div class="author-info__description">Emil`s Blog 是 Hexo 建造的个人博客网站.Java 第三方开源框架源码. 其他语言技术分享. 个人博客搭建.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hvnobug/" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:972080809@qq.com" target="_blank"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">感谢访问本站,若喜欢请收藏 ^_^</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#phase"><span class="toc-number">1.</span> <span class="toc-text">phase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parties"><span class="toc-number">2.</span> <span class="toc-text">parties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arriveadvance"><span class="toc-number">3.</span> <span class="toc-text">arrive&#x2F;advance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#termination"><span class="toc-number">4.</span> <span class="toc-text">termination</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tiering"><span class="toc-number">5.</span> <span class="toc-text">tiering</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">核心属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qnode"><span class="toc-number">7.</span> <span class="toc-text">QNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#register"><span class="toc-number">9.1.</span> <span class="toc-text">register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reconcilestate"><span class="toc-number">9.2.</span> <span class="toc-text">reconcileState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#internalawaitadvance"><span class="toc-number">9.3.</span> <span class="toc-text">internalAwaitAdvance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arrive"><span class="toc-number">9.4.</span> <span class="toc-text">arrive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arriveandawaitadvance"><span class="toc-number">9.5.</span> <span class="toc-text">arriveAndAwaitAdvance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitadvance"><span class="toc-number">9.6.</span> <span class="toc-text">awaitAdvance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/concurrent-phaser.html" title="并发编程 - Phaser"><img data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/58.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="并发编程 - Phaser"></a><div class="content"><a class="title" href="/post/concurrent-phaser.html" title="并发编程 - Phaser">并发编程 - Phaser</a><time datetime="2021-04-07T14:13:12.000Z" title="发表于 2021-04-07 22:13:12">2021-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/concurrent-semaphore.html" title="并发编程 - Semaphore"><img data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/57.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="并发编程 - Semaphore"></a><div class="content"><a class="title" href="/post/concurrent-semaphore.html" title="并发编程 - Semaphore">并发编程 - Semaphore</a><time datetime="2021-04-03T05:33:27.000Z" title="发表于 2021-04-03 13:33:27">2021-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/concurrent-cyclicbarrier.html" title="并发编程 - CyclicBarrier"><img data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/56.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="并发编程 - CyclicBarrier"></a><div class="content"><a class="title" href="/post/concurrent-cyclicbarrier.html" title="并发编程 - CyclicBarrier">并发编程 - CyclicBarrier</a><time datetime="2021-03-27T02:23:57.000Z" title="发表于 2021-03-27 10:23:57">2021-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/concurrent-countdownlatch.html" title="并发编程 - CountDownLatch"><img data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/54.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="并发编程 - CountDownLatch"></a><div class="content"><a class="title" href="/post/concurrent-countdownlatch.html" title="并发编程 - CountDownLatch">并发编程 - CountDownLatch</a><time datetime="2021-03-20T12:13:12.000Z" title="发表于 2021-03-20 20:13:12">2021-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/concurrent-reentrantreadwritelock.html" title="并发编程 - ReentrantReadWriteLock"><img data-lazy-src="https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/54.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="并发编程 - ReentrantReadWriteLock"></a><div class="content"><a class="title" href="/post/concurrent-reentrantreadwritelock.html" title="并发编程 - ReentrantReadWriteLock">并发编程 - ReentrantReadWriteLock</a><time datetime="2021-03-12T05:21:53.000Z" title="发表于 2021-03-12 13:21:53">2021-03-12</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://cdn.jsdelivr.net/gh/hvnobug/assets/blog/album/original-anime/0.png)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Emil</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'wN7GK2Jgd6fz8so4U85XeUxl-9Nh9j0Va',
      appKey: 'JRpha8sPFNqXkv1a0HNIIQFY',
      placeholder: '说点什么吧 ...!',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">點擊刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"點擊刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script src="//code.tidio.co/aksnqalq4y8zibuahby7nqeilrtcb1oi.js" async></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()</script></div><link href="//unpkg.com/aplayer/dist/APlayer.min.css" rel="stylesheet"><script src="//cdn.jsdelivr.net/npm/hls.js@latest"></script><script src="//unpkg.com/aplayer/dist/APlayer.min.js"></script><script src="/assets/aplayer.js" type="text/javascript"></script><script type="text/javascript">const $title = $('.bg-cover .title');
    if ($title.length > 0) {
        $.ajax({
            url: 'https://sdk.jinrishici.com/v2/browser/jinrishici.js',
            dataType: "script",
            cache: true,
            async: false,
            success: function () {
                jinrishici.load(function (result) {
                    // 自己的处理逻辑
                    const {status, data} = result;
                    if (status === 'success') {
                        $title.css('font-size', '3rem');
                        $title.html(data.origin.title + '<span style="font-size:2rem;margin-left:1rem;">' + data.origin.author + '-' + data.origin['dynasty'] + '</span>');
                        typed.strings = data.origin.content.slice(0, 2);
                    }
                });
            }
        });
    }</script><div class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">點擊刷新</a></div></div><script>function showNotification(){var t,e,o;GLOBAL_CONFIG.Snackbar?(t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position,Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})):(o="top: 0; background: "+("light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f")+";",document.getElementById("app-refresh").style.cssText=o)}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}))</script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?url='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script></body></html>